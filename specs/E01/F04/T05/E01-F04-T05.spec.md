---
# ============================================================================
# SPEC METADATA - This entire frontmatter section contains the spec metadata
# ============================================================================

# === IDENTIFICATION ===
id: a0e2a2c5 # Unique identifier (never changes)
title: Docker Multi-stage Build Configuration
type: task

# === HIERARCHY ===
parent: 'E01-F04'
children: []
epic: 'E01'
domain: infrastructure

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-08-28'
updated: '2025-08-28'
due_date: ''
estimated_hours: 2
actual_hours: 0

# === METADATA ===
tags:
  - docker
  - containerization
  - optimization
  - security
effort: small
risk: low
---

# Docker Multi-stage Build Configuration

## Overview

Create production-ready multi-stage Docker configurations for all JTS microservices with emphasis on security hardening, minimal image sizes (<150MB), fast build times, and optimal layer caching. This task establishes the foundation for secure containerized deployment across the trading system infrastructure.

## Acceptance Criteria

- [ ] **Multi-stage Builds**: Separate builder, development, and production stages
- [ ] **Base Image Optimization**: Alpine Linux with shared base image for common dependencies
- [ ] **Security Hardening**: Non-root users, minimal attack surface, security scanning
- [ ] **Layer Caching**: Optimal COPY order and build context for maximum cache efficiency
- [ ] **Health Checks**: Built-in container health validation with proper endpoints
- [ ] **Build Arguments**: Configurable Node version, environment, and feature flags
- [ ] **Size Optimization**: Final images under 150MB per service
- [ ] **.dockerignore**: Comprehensive file exclusion patterns
- [ ] **Container Registry**: GitHub Container Registry integration with proper tagging
- [ ] **GitHub Actions**: Automated Docker build and push workflows

## Technical Implementation

### Base Image Dockerfile

**`docker/base/Dockerfile`**:

```dockerfile
# =============================================================================
# JTS Base Image - Shared dependencies for all microservices
# =============================================================================
ARG NODE_VERSION=20.18.0
FROM node:${NODE_VERSION}-alpine AS base

# Install security updates and essential packages
RUN apk update && apk upgrade && \
    apk add --no-cache \
    dumb-init \
    curl \
    tzdata && \
    rm -rf /var/cache/apk/*

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001 -G nodejs

# Set up application directory
WORKDIR /app
RUN chown nodejs:nodejs /app

# Install global dependencies
RUN npm install -g npm@latest && npm cache clean --force

# Switch to non-root user
USER nodejs

# Health check base configuration
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# =============================================================================
# Builder Stage - Compilation and build artifacts
# =============================================================================
FROM base AS builder

# Install build dependencies as root
USER root
RUN apk add --no-cache python3 make g++ && \
    ln -sf python3 /usr/bin/python

# Switch back to nodejs user
USER nodejs

# Copy dependency files
COPY --chown=nodejs:nodejs package*.json ./
COPY --chown=nodejs:nodejs nx.json ./
COPY --chown=nodejs:nodejs tsconfig*.json ./

# Install all dependencies (including devDependencies)
RUN npm ci --include=dev --prefer-offline

# Copy source code
COPY --chown=nodejs:nodejs . .

# Build arguments for optimization
ARG BUILD_ENV=production
ARG NX_CLOUD_ACCESS_TOKEN
ARG AFFECTED_APPS

# Build the applications
RUN npm run build

# =============================================================================
# Development Stage - Hot reload and debugging
# =============================================================================
FROM base AS development

# Install development tools
USER root
RUN apk add --no-cache git openssh-client

USER nodejs

# Copy package files
COPY --chown=nodejs:nodejs package*.json ./

# Install all dependencies including dev
RUN npm ci --include=dev

# Copy source and built artifacts
COPY --chown=nodejs:nodejs . .

# Expose common ports
EXPOSE 3000 9229

# Development command with hot reload
CMD ["npm", "run", "dev"]

# =============================================================================
# Production Stage - Minimal runtime image
# =============================================================================
FROM base AS production

# Copy only production dependencies
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
COPY --from=builder --chown=nodejs:nodejs /app/package*.json ./

# Remove unnecessary files to reduce image size
RUN npm prune --production && npm cache clean --force

# Set production environment
ENV NODE_ENV=production
ENV NODE_OPTIONS="--max-old-space-size=1024"

# Expose service port
EXPOSE 3000

# Use dumb-init for proper signal handling
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "dist/main.js"]
```

### Microservice-Specific Dockerfiles

**`apps/api-gateway/Dockerfile`**:

```dockerfile
ARG BASE_IMAGE=ghcr.io/ddoachi/jts-base:latest
FROM ${BASE_IMAGE} AS base

# Service-specific build arguments
ARG SERVICE_NAME=api-gateway
ARG SERVICE_PORT=3001

# Copy service-specific files
COPY --chown=nodejs:nodejs apps/api-gateway ./apps/api-gateway
COPY --chown=nodejs:nodejs libs ./libs

# Build the service
RUN npx nx build api-gateway --prod

FROM ${BASE_IMAGE} AS production

# Copy built application
COPY --from=base --chown=nodejs:nodejs /app/dist/apps/api-gateway ./

# Service-specific configuration
ENV SERVICE_NAME=api-gateway
ENV PORT=${SERVICE_PORT}
EXPOSE ${SERVICE_PORT}

# Health check for API Gateway
HEALTHCHECK --interval=15s --timeout=5s --start-period=30s --retries=3 \
  CMD curl -f http://localhost:${SERVICE_PORT}/health || exit 1

CMD ["node", "main.js"]
```

**`apps/strategy-engine/Dockerfile`**:

```dockerfile
ARG BASE_IMAGE=ghcr.io/ddoachi/jts-base:latest
FROM ${BASE_IMAGE} AS base

# Strategy engine specific dependencies
USER root
RUN apk add --no-cache \
    python3 \
    python3-dev \
    py3-numpy \
    py3-pandas && \
    rm -rf /var/cache/apk/*

USER nodejs

ARG SERVICE_NAME=strategy-engine
ARG SERVICE_PORT=3002

# Copy service files
COPY --chown=nodejs:nodejs apps/strategy-engine ./apps/strategy-engine
COPY --chown=nodejs:nodejs libs ./libs

# Install strategy-specific packages
RUN npm install --production-only

# Build the service
RUN npx nx build strategy-engine --prod

FROM ${BASE_IMAGE} AS production

# Copy Python runtime
COPY --from=base /usr/lib/python3.11 /usr/lib/python3.11
COPY --from=base /usr/bin/python3 /usr/bin/python3

# Copy built application
COPY --from=base --chown=nodejs:nodejs /app/dist/apps/strategy-engine ./

ENV SERVICE_NAME=strategy-engine
ENV PORT=${SERVICE_PORT}
ENV PYTHON_PATH=/usr/lib/python3.11

EXPOSE ${SERVICE_PORT}

# Strategy engine health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
  CMD curl -f http://localhost:${SERVICE_PORT}/health/strategy || exit 1

CMD ["node", "main.js"]
```

**`apps/order-execution/Dockerfile`**:

```dockerfile
ARG BASE_IMAGE=ghcr.io/ddoachi/jts-base:latest
FROM ${BASE_IMAGE} AS base

ARG SERVICE_NAME=order-execution
ARG SERVICE_PORT=3003

# Copy service files
COPY --chown=nodejs:nodejs apps/order-execution ./apps/order-execution
COPY --chown=nodejs:nodejs libs ./libs

# Build with security optimizations
RUN npx nx build order-execution --prod --optimization

FROM ${BASE_IMAGE} AS production

# Copy built application
COPY --from=base --chown=nodejs:nodejs /app/dist/apps/order-execution ./

ENV SERVICE_NAME=order-execution
ENV PORT=${SERVICE_PORT}

# Enhanced security for order execution
ENV NODE_OPTIONS="--max-old-space-size=512 --enable-source-maps=false"

EXPOSE ${SERVICE_PORT}

# Critical service health check
HEALTHCHECK --interval=10s --timeout=3s --start-period=30s --retries=5 \
  CMD curl -f http://localhost:${SERVICE_PORT}/health/orders || exit 1

CMD ["node", "main.js"]
```

### Docker Build Optimization

**Layer Caching Strategy**:

```dockerfile
# 1. Copy dependency files first (changes rarely)
COPY package*.json ./
COPY nx.json ./

# 2. Install dependencies (cached until package.json changes)
RUN npm ci --prefer-offline

# 3. Copy source code last (changes frequently)
COPY . .

# 4. Build application
RUN npm run build
```

**Build Context Optimization (.dockerignore)**:

```dockerignore
# Development files
node_modules
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# IDE files
.vscode
.idea
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Git
.git
.gitignore

# CI/CD
.github
.gitlab-ci.yml

# Documentation
README.md
docs/
*.md

# Test files
**/*.test.ts
**/*.spec.ts
test/
coverage/

# Build artifacts
dist/
build/
.nx/

# Environment files
.env*
!.env.example

# Logs
logs/
*.log

# Cache directories
.npm
.cache
.eslintcache

# Temporary files
tmp/
temp/
*.tmp
```

### GitHub Actions Docker Workflow

**`.github/workflows/docker-build.yml`**:

```yaml
name: Docker Build and Push

on:
  push:
    branches: [main, develop]
    paths:
      - 'apps/**'
      - 'libs/**'
      - 'docker/**'
      - 'Dockerfile*'
  pull_request:
    branches: [main]
    paths:
      - 'apps/**'
      - 'libs/**'
      - 'docker/**'
      - 'Dockerfile*'

concurrency:
  group: docker-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-base:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      base-image: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Base Image Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-base
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and Push Base Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/base/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_VERSION=20.18.0
            BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VCS_REF=${{ github.sha }}

  build-services:
    needs: build-base
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write
    strategy:
      matrix:
        service:
          - api-gateway
          - strategy-engine
          - order-execution
          - risk-management
          - data-ingestion
          - notification-service
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract Service Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and Push Service Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/${{ matrix.service }}/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BASE_IMAGE=${{ needs.build-base.outputs.base-image }}
            SERVICE_NAME=${{ matrix.service }}
            BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VCS_REF=${{ github.sha }}

      - name: Run Trivy Vulnerability Scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.meta.outputs.tags }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy Scan Results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
```

### Security Configuration

**Security Hardening Checklist**:

```dockerfile
# 1. Use specific base image versions
FROM node:20.18.0-alpine AS base

# 2. Update packages and install security patches
RUN apk update && apk upgrade

# 3. Create non-root user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001 -G nodejs

# 4. Remove unnecessary packages
RUN apk del --no-network python3 make g++

# 5. Use read-only filesystem where possible
RUN chmod -R 755 /app

# 6. Set security labels
LABEL \
  org.opencontainers.image.title="JTS Trading Service" \
  org.opencontainers.image.description="Secure containerized trading microservice" \
  org.opencontainers.image.vendor="JTS Trading System" \
  security.scan-policy="strict"
```

### Container Registry Configuration

**GitHub Container Registry Setup**:

```yaml
# .github/workflows/cleanup-packages.yml
name: Cleanup Container Images

on:
  schedule:
    - cron: '0 2 * * 0' # Weekly cleanup
  workflow_dispatch:

jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      packages: write
    steps:
      - name: Delete Untagged Images
        uses: actions/delete-package-versions@v4
        with:
          package-name: ${{ github.repository }}
          package-type: container
          min-versions-to-keep: 10
          delete-only-untagged-versions: true
```

### Health Check Implementation

**Advanced Health Checks**:

```typescript
// libs/common/src/health/docker-health.ts
export class DockerHealthCheck {
  private checks = new Map<string, () => Promise<boolean>>();

  async performHealthCheck(): Promise<{ status: string; checks: any }> {
    const results = await Promise.allSettled(
      Array.from(this.checks.entries()).map(async ([name, check]) => ({
        name,
        status: (await check()) ? 'healthy' : 'unhealthy',
      })),
    );

    const healthy = results.every((r) => r.status === 'fulfilled' && r.value.status === 'healthy');

    return {
      status: healthy ? 'healthy' : 'unhealthy',
      checks: results.map((r) =>
        r.status === 'fulfilled' ? r.value : { name: 'unknown', status: 'error' },
      ),
    };
  }
}
```

## Testing Plan

### Container Security Testing

- Trivy vulnerability scanning in CI pipeline
- Container image signing with cosign
- Runtime security monitoring with Falco
- Network policy validation in Kubernetes

### Performance Testing

- Image size validation (<150MB per service)
- Build time optimization (target <5 minutes)
- Container startup time (<30 seconds)
- Memory usage profiling under load

### Integration Testing

- Multi-service container orchestration
- Health check endpoint validation
- Service discovery and communication
- Database connection pooling

### Build Testing

- Multi-platform build verification (AMD64/ARM64)
- Layer caching effectiveness measurement
- Docker registry push/pull operations
- Rollback scenario validation

## Success Metrics

### Image Optimization

- Final production images under 150MB per service
- Build cache hit rate >80%
- Total build time reduction >40% compared to baseline
- Registry storage optimization >60%

### Security Compliance

- Zero critical vulnerabilities in production images
- All containers run as non-root users
- Security scan pass rate 100%
- CVE remediation time <24 hours

### Operational Excellence

- Container startup time <30 seconds
- Health check response time <1 second
- Build success rate >99%
- Deployment rollback time <2 minutes

## Notes

### Production Considerations

- Implement proper resource limits in Kubernetes
- Use init containers for database migrations
- Configure proper logging with structured JSON format
- Implement graceful shutdown handling with SIGTERM

### Monitoring Integration

- Container metrics collection with Prometheus
- Log aggregation with ELK stack
- APM integration with New Relic or DataDog
- Alert configuration for container failures

### Compliance Requirements

- Financial services security standards
- Data privacy regulations (GDPR, CCPA)
- Audit trail for all container deployments
- Backup and disaster recovery procedures
