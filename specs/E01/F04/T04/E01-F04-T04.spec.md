---
# ============================================================================
# SPEC METADATA - This entire frontmatter section contains the spec metadata
# ============================================================================

# === IDENTIFICATION ===
id: 1019c809 # Unique identifier (never changes)
title: Deployment Pipeline Workflows
type: task

# === HIERARCHY ===
parent: "E01-F04"
children: []
epic: "E01"
domain: infrastructure

# === WORKFLOW ===
status: draft
priority: high

# === TRACKING ===
created: '2025-08-28'
updated: '2025-09-05'
due_date: ''
estimated_hours: 8
actual_hours: 0

# === METADATA ===
tags:
  - deployment
  - blue-green
  - rollback
  - kubernetes
  - prometheus
  - zero-downtime
effort: large
risk: high
---

# Deployment Pipeline Workflows

## Overview

Implement production-ready deployment pipeline workflows for the JTS trading system with zero-downtime requirements. This task creates environment-specific workflows (development, staging, production) using blue-green deployment strategy, automated rollback mechanisms, database migration safety checks, and comprehensive monitoring integration for a high-frequency trading environment.

## Acceptance Criteria

- [ ] **Development Deployment**: Auto-deploy on merge to develop branch with basic health checks
- [ ] **Staging Deployment**: Deploy with comprehensive smoke tests and performance validation
- [ ] **Production Deployment**: Manual approval gates with blue-green deployment and circuit breaker protection
- [ ] **Blue-Green Implementation**: Zero-downtime Kubernetes deployments with traffic switching
- [ ] **Database Migrations**: Safe migration execution with rollback capability
- [ ] **Automated Rollback**: Health check-triggered rollbacks with performance thresholds
- [ ] **Gradual Rollouts**: Canary deployments with automated monitoring
- [ ] **Secret Management**: GitHub Secrets integration with Kubernetes secrets
- [ ] **Monitoring Integration**: Prometheus metrics and Grafana dashboards for deployment tracking
- [ ] **Circuit Breaker**: Automated deployment halts on system health degradation

## Technical Implementation

### Development Deployment Workflow

**`.github/workflows/deploy-dev.yml`**:

```yaml
name: Deploy to Development

on:
  push:
    branches: [develop]
  workflow_dispatch:

concurrency:
  group: deploy-dev-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  ENVIRONMENT: development
  KUBECONFIG_DATA: ${{ secrets.DEV_KUBECONFIG }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: development
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Push Images
        run: |
          services=("api-gateway" "strategy-engine" "order-execution" "risk-management")
          for service in "${services[@]}"; do
            docker build \
              --file apps/$service/Dockerfile \
              --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/$service:dev-${{ github.sha }} \
              --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/$service:dev-latest \
              --platform linux/amd64 \
              --push .
          done

      - name: Setup Kubernetes CLI
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure Kubernetes
        run: |
          echo "${{ env.KUBECONFIG_DATA }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Deploy to Development
        run: |
          export KUBECONFIG=kubeconfig
          export IMAGE_TAG=dev-${{ github.sha }}
          
          # Apply Kubernetes manifests
          kubectl apply -f k8s/namespaces/development.yml
          envsubst < k8s/deployments/api-gateway.yml | kubectl apply -f -
          envsubst < k8s/deployments/strategy-engine.yml | kubectl apply -f -
          envsubst < k8s/deployments/order-execution.yml | kubectl apply -f -
          envsubst < k8s/deployments/risk-management.yml | kubectl apply -f -
          
          # Apply services and ingress
          kubectl apply -f k8s/services/ -n development
          kubectl apply -f k8s/ingress/development.yml

      - name: Wait for Deployment
        run: |
          export KUBECONFIG=kubeconfig
          kubectl rollout status deployment/api-gateway -n development --timeout=300s
          kubectl rollout status deployment/strategy-engine -n development --timeout=300s
          kubectl rollout status deployment/order-execution -n development --timeout=300s
          kubectl rollout status deployment/risk-management -n development --timeout=300s

      - name: Health Check
        run: |
          max_attempts=30
          attempt=0
          
          while [ $attempt -lt $max_attempts ]; do
            if curl -f -s "https://dev-api.jts.com/health" > /dev/null; then
              echo "Health check passed"
              exit 0
            fi
            attempt=$((attempt + 1))
            sleep 10
          done
          
          echo "Health check failed after $max_attempts attempts"
          exit 1

      - name: Notify Deployment
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
          fields: repo,commit,author,action,eventName,ref,workflow
```

### Staging Deployment Workflow

**`.github/workflows/deploy-staging.yml`**:

```yaml
name: Deploy to Staging

on:
  push:
    branches: [release/*]
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy'
        required: true
        default: 'latest'

concurrency:
  group: deploy-staging
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  ENVIRONMENT: staging

jobs:
  database-migration:
    runs-on: ubuntu-latest
    environment: staging
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Run Database Migrations
        run: |
          # PostgreSQL migrations
          export PGPASSWORD="${{ secrets.STAGING_DB_PASSWORD }}"
          
          # Check current migration version
          current_version=$(psql -h ${{ secrets.STAGING_DB_HOST }} \
            -U ${{ secrets.STAGING_DB_USER }} \
            -d ${{ secrets.STAGING_DB_NAME }} \
            -t -c "SELECT version FROM schema_migrations ORDER BY version DESC LIMIT 1;" | xargs)
          
          echo "Current migration version: $current_version"
          
          # Run migrations with safety checks
          npm run migration:run:staging
          
          # Verify migrations completed successfully
          new_version=$(psql -h ${{ secrets.STAGING_DB_HOST }} \
            -U ${{ secrets.STAGING_DB_USER }} \
            -d ${{ secrets.STAGING_DB_NAME }} \
            -t -c "SELECT version FROM schema_migrations ORDER BY version DESC LIMIT 1;" | xargs)
          
          echo "New migration version: $new_version"

  blue-green-deploy:
    needs: database-migration
    runs-on: ubuntu-latest
    environment: staging
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Kubernetes CLI
        uses: azure/setup-kubectl@v3

      - name: Configure Kubernetes
        run: |
          echo "${{ secrets.STAGING_KUBECONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Blue-Green Deployment
        run: |
          export KUBECONFIG=kubeconfig
          export IMAGE_TAG=${{ github.event.inputs.image_tag || 'staging-latest' }}
          
          # Determine current active environment (blue or green)
          current_env=$(kubectl get service api-gateway-active -n staging -o jsonpath='{.spec.selector.version}' || echo "blue")
          target_env=$([ "$current_env" = "blue" ] && echo "green" || echo "blue")
          
          echo "Current environment: $current_env"
          echo "Target environment: $target_env"
          
          # Deploy to target environment
          export TARGET_ENV=$target_env
          envsubst < k8s/deployments/blue-green/api-gateway-${target_env}.yml | kubectl apply -f -
          envsubst < k8s/deployments/blue-green/strategy-engine-${target_env}.yml | kubectl apply -f -
          envsubst < k8s/deployments/blue-green/order-execution-${target_env}.yml | kubectl apply -f -
          envsubst < k8s/deployments/blue-green/risk-management-${target_env}.yml | kubectl apply -f -
          
          # Wait for deployment to be ready
          kubectl rollout status deployment/api-gateway-${target_env} -n staging --timeout=600s
          kubectl rollout status deployment/strategy-engine-${target_env} -n staging --timeout=600s
          kubectl rollout status deployment/order-execution-${target_env} -n staging --timeout=600s
          kubectl rollout status deployment/risk-management-${target_env} -n staging --timeout=600s

      - name: Smoke Tests
        run: |
          export KUBECONFIG=kubeconfig
          
          # Get target environment service endpoint
          target_env=$([ "$(kubectl get service api-gateway-active -n staging -o jsonpath='{.spec.selector.version}')" = "blue" ] && echo "green" || echo "blue")
          target_ip=$(kubectl get service api-gateway-${target_env} -n staging -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          
          # Run comprehensive smoke tests
          npm run test:smoke -- --endpoint="http://${target_ip}"
          
          # Performance validation
          npm run test:performance -- --endpoint="http://${target_ip}" --threshold=500ms

      - name: Switch Traffic
        run: |
          export KUBECONFIG=kubeconfig
          
          # Get target environment
          current_env=$(kubectl get service api-gateway-active -n staging -o jsonpath='{.spec.selector.version}' || echo "blue")
          target_env=$([ "$current_env" = "blue" ] && echo "green" || echo "blue")
          
          # Update active service selectors to point to target environment
          kubectl patch service api-gateway-active -n staging -p '{"spec":{"selector":{"version":"'$target_env'"}}}'
          kubectl patch service strategy-engine-active -n staging -p '{"spec":{"selector":{"version":"'$target_env'"}}}'
          kubectl patch service order-execution-active -n staging -p '{"spec":{"selector":{"version":"'$target_env'"}}}'
          kubectl patch service risk-management-active -n staging -p '{"spec":{"selector":{"version":"'$target_env'"}}}'
          
          echo "Traffic switched to $target_env environment"

      - name: Post-Deployment Validation
        run: |
          # Wait for traffic to stabilize
          sleep 30
          
          # Validate all services are responding
          curl -f "https://staging-api.jts.com/health"
          curl -f "https://staging-api.jts.com/api/strategy/health"
          curl -f "https://staging-api.jts.com/api/order/health"
          curl -f "https://staging-api.jts.com/api/risk/health"
          
          # Performance check
          response_time=$(curl -o /dev/null -s -w '%{time_total}' "https://staging-api.jts.com/api/market/status")
          if (( $(echo "$response_time > 1.0" | bc -l) )); then
            echo "Response time too high: ${response_time}s"
            exit 1
          fi

  cleanup-old-environment:
    needs: blue-green-deploy
    runs-on: ubuntu-latest
    if: success()
    
    steps:
      - name: Cleanup Old Environment
        run: |
          export KUBECONFIG=kubeconfig
          
          # Get old environment (the one we switched away from)
          current_env=$(kubectl get service api-gateway-active -n staging -o jsonpath='{.spec.selector.version}')
          old_env=$([ "$current_env" = "blue" ] && echo "green" || echo "blue")
          
          # Keep old environment for rollback capability (don't delete)
          echo "Keeping $old_env environment for rollback capability"
          
          # Scale down old environment to save resources
          kubectl scale deployment api-gateway-${old_env} --replicas=1 -n staging
          kubectl scale deployment strategy-engine-${old_env} --replicas=1 -n staging
          kubectl scale deployment order-execution-${old_env} --replicas=1 -n staging
          kubectl scale deployment risk-management-${old_env} --replicas=1 -n staging
```

### Production Deployment Workflow

**`.github/workflows/deploy-production.yml`**:

```yaml
name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy'
        required: true
      rollout_strategy:
        description: 'Deployment strategy'
        required: true
        default: 'blue-green'
        type: choice
        options:
        - blue-green
        - canary

concurrency:
  group: deploy-production
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  ENVIRONMENT: production

jobs:
  pre-deployment-checks:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Verify Image Exists
        run: |
          services=("api-gateway" "strategy-engine" "order-execution" "risk-management")
          for service in "${services[@]}"; do
            docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/$service:${{ github.event.inputs.image_tag }}
          done

      - name: Security Scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api-gateway:${{ github.event.inputs.image_tag }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Check System Health
        run: |
          # Verify production system is healthy before deployment
          curl -f "https://api.jts.com/health" || exit 1
          
          # Check trading system status
          trading_status=$(curl -s "https://api.jts.com/api/system/status" | jq -r '.trading_enabled')
          if [ "$trading_status" = "true" ]; then
            echo "WARNING: Trading is currently active"
            echo "Consider deploying during off-market hours"
          fi

  database-migration:
    needs: pre-deployment-checks
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Create Migration Backup
        run: |
          export PGPASSWORD="${{ secrets.PROD_DB_PASSWORD }}"
          
          # Create backup before migration
          pg_dump -h ${{ secrets.PROD_DB_HOST }} \
            -U ${{ secrets.PROD_DB_USER }} \
            -d ${{ secrets.PROD_DB_NAME }} \
            -f backup_$(date +%Y%m%d_%H%M%S).sql
          
          # Upload backup to S3
          aws s3 cp backup_*.sql s3://jts-db-backups/production/

      - name: Run Production Migrations
        run: |
          export PGPASSWORD="${{ secrets.PROD_DB_PASSWORD }}"
          
          # Check migration compatibility
          npm run migration:check:production
          
          # Run migrations with transaction safety
          npm run migration:run:production
          
          # Verify data integrity
          npm run migration:verify:production

  blue-green-deployment:
    needs: database-migration
    runs-on: ubuntu-latest
    environment: production
    if: github.event.inputs.rollout_strategy == 'blue-green'
    
    steps:
      - name: Setup Production Environment
        run: |
          echo "${{ secrets.PROD_KUBECONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Blue-Green Production Deploy
        run: |
          export KUBECONFIG=kubeconfig
          export IMAGE_TAG=${{ github.event.inputs.image_tag }}
          
          # Get current environment
          current_env=$(kubectl get service api-gateway-active -n production -o jsonpath='{.spec.selector.version}' 2>/dev/null || echo "blue")
          target_env=$([ "$current_env" = "blue" ] && echo "green" || echo "blue")
          
          echo "Deploying to $target_env environment"
          
          # Deploy with resource limits for production
          export TARGET_ENV=$target_env
          export CPU_REQUEST="1000m"
          export CPU_LIMIT="2000m"
          export MEMORY_REQUEST="2Gi"
          export MEMORY_LIMIT="4Gi"
          
          envsubst < k8s/production/api-gateway-${target_env}.yml | kubectl apply -f -
          envsubst < k8s/production/strategy-engine-${target_env}.yml | kubectl apply -f -
          envsubst < k8s/production/order-execution-${target_env}.yml | kubectl apply -f -
          envsubst < k8s/production/risk-management-${target_env}.yml | kubectl apply -f -

      - name: Production Health Validation
        run: |
          export KUBECONFIG=kubeconfig
          
          # Wait for all deployments
          kubectl rollout status deployment/api-gateway-${target_env} -n production --timeout=900s
          kubectl rollout status deployment/strategy-engine-${target_env} -n production --timeout=900s
          kubectl rollout status deployment/order-execution-${target_env} -n production --timeout=900s
          kubectl rollout status deployment/risk-management-${target_env} -n production --timeout=900s
          
          # Comprehensive health checks
          target_ip=$(kubectl get service api-gateway-${target_env} -n production -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          
          # API health check
          curl -f "http://${target_ip}/health"
          
          # Database connectivity check
          curl -f "http://${target_ip}/api/health/database"
          
          # External service connectivity
          curl -f "http://${target_ip}/api/health/external"
          
          # Performance benchmark
          ab -n 1000 -c 10 "http://${target_ip}/api/market/status" | tee performance_results.txt
          
          # Validate response times
          avg_response=$(grep "Time per request" performance_results.txt | head -1 | awk '{print $4}')
          if (( $(echo "$avg_response > 200" | bc -l) )); then
            echo "Average response time too high: ${avg_response}ms"
            exit 1
          fi

      - name: Gradual Traffic Switch
        run: |
          export KUBECONFIG=kubeconfig
          
          # Switch traffic gradually with monitoring
          for percentage in 10 25 50 75 100; do
            echo "Switching ${percentage}% traffic to new environment"
            
            # Update traffic weights
            kubectl patch virtualservice api-gateway -n production --type merge -p '{
              "spec": {
                "http": [{
                  "match": [{"headers": {"canary": {"exact": "true"}}}],
                  "route": [{"destination": {"host": "api-gateway-'$target_env'", "port": {"number": 8080}}, "weight": '$percentage'}]
                }, {
                  "route": [{"destination": {"host": "api-gateway-'$current_env'", "port": {"number": 8080}}, "weight": '$((100-percentage))'}]
                }]
              }
            }'
            
            # Monitor for 2 minutes
            sleep 120
            
            # Check error rates
            error_rate=$(curl -s "http://prometheus.jts.com/api/v1/query?query=rate(http_requests_total{status=~\"5.*\"}[5m])" | jq -r '.data.result[0].value[1]')
            if (( $(echo "$error_rate > 0.01" | bc -l) )); then
              echo "Error rate too high during gradual rollout: $error_rate"
              exit 1
            fi
            
            # Check response times
            response_time=$(curl -s "http://prometheus.jts.com/api/v1/query?query=histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))" | jq -r '.data.result[0].value[1]')
            if (( $(echo "$response_time > 0.5" | bc -l) )); then
              echo "Response time too high during gradual rollout: $response_time"
              exit 1
            fi
          done

      - name: Final Production Validation
        run: |
          # Final comprehensive validation
          sleep 60
          
          # Trading system validation
          curl -f "https://api.jts.com/api/trading/status"
          
          # Market data validation
          curl -f "https://api.jts.com/api/market/feed"
          
          # Order execution validation
          curl -f "https://api.jts.com/api/order/health"
          
          echo "Production deployment completed successfully"

  automated-rollback:
    needs: blue-green-deployment
    runs-on: ubuntu-latest
    if: failure()
    
    steps:
      - name: Emergency Rollback
        run: |
          export KUBECONFIG=kubeconfig
          
          # Switch back to previous environment immediately
          current_env=$(kubectl get service api-gateway-active -n production -o jsonpath='{.spec.selector.version}')
          previous_env=$([ "$current_env" = "blue" ] && echo "green" || echo "blue")
          
          echo "Rolling back to $previous_env environment"
          
          # Immediate traffic switch
          kubectl patch service api-gateway-active -n production -p '{"spec":{"selector":{"version":"'$previous_env'"}}}'
          kubectl patch service strategy-engine-active -n production -p '{"spec":{"selector":{"version":"'$previous_env'"}}}'
          kubectl patch service order-execution-active -n production -p '{"spec":{"selector":{"version":"'$previous_env'"}}}'
          kubectl patch service risk-management-active -n production -p '{"spec":{"selector":{"version":"'$previous_env'"}}}'
          
          # Scale up previous environment
          kubectl scale deployment api-gateway-${previous_env} --replicas=5 -n production
          kubectl scale deployment strategy-engine-${previous_env} --replicas=3 -n production
          kubectl scale deployment order-execution-${previous_env} --replicas=5 -n production
          kubectl scale deployment risk-management-${previous_env} --replicas=3 -n production
          
          # Notify emergency rollback
          curl -X POST ${{ secrets.SLACK_WEBHOOK_URL }} \
            -H 'Content-type: application/json' \
            --data '{"text":"🚨 EMERGENCY ROLLBACK: Production deployment failed and has been rolled back automatically"}'
```

### Kubernetes Manifests

**`k8s/production/api-gateway-blue.yml`**:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-gateway-blue
  namespace: production
  labels:
    app: api-gateway
    version: blue
spec:
  replicas: 5
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 2
      maxUnavailable: 1
  selector:
    matchLabels:
      app: api-gateway
      version: blue
  template:
    metadata:
      labels:
        app: api-gateway
        version: blue
    spec:
      containers:
      - name: api-gateway
        image: ${REGISTRY}/${IMAGE_NAME}/api-gateway:${IMAGE_TAG}
        ports:
        - containerPort: 8080
        resources:
          requests:
            cpu: ${CPU_REQUEST}
            memory: ${MEMORY_REQUEST}
          limits:
            cpu: ${CPU_LIMIT}
            memory: ${MEMORY_LIMIT}
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: production-secrets
              key: database-url
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
          failureThreshold: 3
        lifecycle:
          preStop:
            exec:
              command: ["/bin/sh", "-c", "sleep 15"]
---
apiVersion: v1
kind: Service
metadata:
  name: api-gateway-blue
  namespace: production
spec:
  type: LoadBalancer
  selector:
    app: api-gateway
    version: blue
  ports:
  - port: 80
    targetPort: 8080
    protocol: TCP
```

### Rollback Workflow

**`.github/workflows/rollback-production.yml`**:

```yaml
name: Production Rollback

on:
  workflow_dispatch:
    inputs:
      rollback_reason:
        description: 'Reason for rollback'
        required: true
      notify_teams:
        description: 'Notify all teams'
        type: boolean
        default: true

jobs:
  emergency-rollback:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Setup Kubernetes
        run: |
          echo "${{ secrets.PROD_KUBECONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Identify Current Environment
        id: current-env
        run: |
          export KUBECONFIG=kubeconfig
          current=$(kubectl get service api-gateway-active -n production -o jsonpath='{.spec.selector.version}')
          previous=$([ "$current" = "blue" ] && echo "green" || echo "blue")
          
          echo "current=$current" >> $GITHUB_OUTPUT
          echo "previous=$previous" >> $GITHUB_OUTPUT

      - name: Execute Rollback
        run: |
          export KUBECONFIG=kubeconfig
          
          # Switch services back to previous environment
          kubectl patch service api-gateway-active -n production -p '{"spec":{"selector":{"version":"${{ steps.current-env.outputs.previous }}"}}}'
          kubectl patch service strategy-engine-active -n production -p '{"spec":{"selector":{"version":"${{ steps.current-env.outputs.previous }}"}}}'
          kubectl patch service order-execution-active -n production -p '{"spec":{"selector":{"version":"${{ steps.current-env.outputs.previous }}"}}}'
          kubectl patch service risk-management-active -n production -p '{"spec":{"selector":{"version":"${{ steps.current-env.outputs.previous }}"}}}'
          
          echo "Rollback completed to ${{ steps.current-env.outputs.previous }} environment"

      - name: Validate Rollback
        run: |
          sleep 30
          
          # Validate all services are responding
          curl -f "https://api.jts.com/health"
          curl -f "https://api.jts.com/api/trading/status"
          
          echo "Rollback validation successful"

      - name: Notify Teams
        if: github.event.inputs.notify_teams == 'true'
        run: |
          curl -X POST ${{ secrets.SLACK_WEBHOOK_URL }} \
            -H 'Content-type: application/json' \
            --data '{
              "text": "🔄 Production Rollback Completed",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Production Rollback Executed*\n*Reason:* ${{ github.event.inputs.rollback_reason }}\n*Rolled back to:* ${{ steps.current-env.outputs.previous }} environment\n*Executed by:* ${{ github.actor }}"
                  }
                }
              ]
            }'
```

### Monitoring and Alerting Integration

**`k8s/monitoring/deployment-metrics.yml`**:

```yaml
apiVersion: v1
kind: ServiceMonitor
metadata:
  name: deployment-metrics
  namespace: monitoring
spec:
  selector:
    matchLabels:
      monitoring: enabled
  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics
---
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: deployment-alerts
  namespace: monitoring
spec:
  groups:
  - name: deployment.rules
    rules:
    - alert: DeploymentFailed
      expr: kube_deployment_status_replicas_unavailable > 0
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "Deployment has unavailable replicas"
        description: "Deployment {{ $labels.deployment }} has {{ $value }} unavailable replicas"
    
    - alert: HighErrorRate
      expr: rate(http_requests_total{status=~"5.*"}[5m]) > 0.01
      for: 2m
      labels:
        severity: warning
      annotations:
        summary: "High error rate detected"
        description: "Error rate is {{ $value }} which is above the 1% threshold"
    
    - alert: HighResponseTime
      expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 0.5
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High response time detected"
        description: "95th percentile response time is {{ $value }}s which is above 500ms threshold"
```

## Testing Plan

- **Workflow Syntax Validation**: GitHub Actions workflow linter validation
- **Blue-Green Deployment Testing**: Test traffic switching with mock environments  
- **Rollback Mechanism Testing**: Simulate failures and validate automated rollback
- **Database Migration Safety**: Test migration rollbacks and data integrity
- **Performance Validation**: Load testing during deployment process
- **Security Scanning**: Container image vulnerability scanning
- **Health Check Validation**: Test all health check endpoints and thresholds
- **Monitoring Integration**: Validate Prometheus metrics and alert firing

## Success Metrics

- **Zero-Downtime Deployments**: 100% uptime during deployment process
- **Deployment Speed**: Development deployments under 5 minutes, production under 15 minutes
- **Rollback Time**: Automated rollbacks complete within 2 minutes
- **Success Rate**: 99.9% deployment success rate across all environments
- **Performance Impact**: Less than 5% performance degradation during deployment
- **Alert Response**: Critical alerts fire within 1 minute of issue detection
- **Health Check Coverage**: 100% service health validation before traffic switch

## Files

- `.github/workflows/deploy-dev.yml` - Development auto-deployment workflow
- `.github/workflows/deploy-staging.yml` - Staging deployment with blue-green strategy  
- `.github/workflows/deploy-production.yml` - Production deployment with approval gates
- `.github/workflows/rollback-production.yml` - Emergency rollback workflow
- `k8s/production/api-gateway-blue.yml` - Blue environment Kubernetes manifest
- `k8s/production/api-gateway-green.yml` - Green environment Kubernetes manifest
- `k8s/production/strategy-engine-blue.yml` - Strategy engine blue environment
- `k8s/production/strategy-engine-green.yml` - Strategy engine green environment
- `k8s/production/order-execution-blue.yml` - Order execution blue environment
- `k8s/production/order-execution-green.yml` - Order execution green environment
- `k8s/production/risk-management-blue.yml` - Risk management blue environment
- `k8s/production/risk-management-green.yml` - Risk management green environment
- `k8s/services/production-active-services.yml` - Active service definitions
- `k8s/ingress/production-ingress.yml` - Production ingress configuration
- `k8s/monitoring/deployment-metrics.yml` - Deployment monitoring configuration
- `scripts/migration-safety-check.sh` - Database migration validation script
- `scripts/deployment-validation.sh` - Post-deployment validation script
