# E13: Status API for Spec Dashboard - Context Log

## Spec Information

- **Spec ID**: E13
- **Title**: Status API for Spec Dashboard
- **Type**: Epic
- **Status**: Draft
- **GitHub Issue**: [To be created]
- **Created**: 2025-09-04
- **Updated**: 2025-09-04

---

## Architectural Analysis

### Implementation Complexity Assessment

**Overall Difficulty Rating: 6/10**

The Status API implementation presents moderate complexity due to the need for real-time updates, efficient file system monitoring, and multi-format data processing. However, it leverages existing parsing infrastructure from the JTS project, which reduces implementation effort.

#### Complexity Breakdown by Component

| Component                   | Difficulty | Justification                                                   |
| --------------------------- | ---------- | --------------------------------------------------------------- |
| Real-time WebSocket/SSE     | 7/10       | Requires efficient connection management and event broadcasting |
| File watching with chokidar | 6/10       | Must handle file system events reliably across environments     |
| Caching strategy            | 5/10       | Balancing memory usage with performance requirements            |
| REST API endpoints          | 4/10       | Straightforward implementation with NestJS                      |

#### Development Effort Estimation

**Phase 1 (MVP)**: 8-10 developer-days

- Basic REST endpoints: 3 days
- File parsing integration: 2 days
- Basic caching: 1 day
- Testing and debugging: 2-4 days

**Phase 2 (Real-time)**: 6-8 developer-days

- WebSocket/SSE implementation: 4 days
- Advanced caching with Redis: 2 days
- Performance optimization: 2 days

**Phase 3 (Optimization)**: 4-6 developer-days

- GraphQL implementation: 3 days
- Advanced querying/filtering: 2-3 days

#### Risk Assessment & Mitigation

1. **File System Watching Performance**
   - Risk: Performance degradation with large number of files
   - Mitigation: Implement debouncing and rate limiting for file events

2. **Memory Leaks from WebSocket Connections**
   - Risk: Unbounded connection growth
   - Mitigation: Connection pooling with timeout and cleanup mechanisms

3. **Cache Invalidation Complexity**
   - Risk: Stale data served to clients
   - Mitigation: Event-driven cache invalidation with fallback strategies

---

## Architecture Design

### Architectural Pattern

**Hybrid Microservice Module** - A single NestJS service within the monorepo that can be easily extracted to a separate microservice if needed.

### Technology Stack

- **Core Framework**: NestJS with TypeScript
- **File Watching**: chokidar (efficient file system monitoring)
- **YAML Processing**: gray-matter (frontmatter extraction)
- **Caching**: Redis (distributed caching)
- **Real-time**: WebSocket with Socket.IO + SSE fallback
- **API Documentation**: Swagger/OpenAPI
- **Validation**: class-validator and class-transformer

### Service Structure

```
apps/status-api/
├── src/
│   ├── app/                    # Main NestJS module
│   │   ├── status.module.ts    # Root module configuration
│   │   ├── status.controller.ts # REST endpoints
│   │   └── status.gateway.ts   # WebSocket gateway
│   ├── domain/                 # Business logic
│   │   ├── spec-parser/        # Spec file parsing logic
│   │   ├── spec-watcher/       # File system monitoring
│   │   ├── cache-manager/      # Caching strategies
│   │   └── statistics/         # Statistics calculation
│   ├── infra/                  # External integrations
│   │   ├── redis/              # Redis client and config
│   │   └── file-system/        # File system operations
│   └── shared/                 # Common utilities
│       ├── dto/                # Data transfer objects
│       ├── interfaces/         # TypeScript interfaces
│       └── utils/              # Helper functions
```

---

## Technical Implementation Details

### Database Strategy

| Database    | Purpose           | Usage                                                 |
| ----------- | ----------------- | ----------------------------------------------------- |
| Redis       | Primary cache     | Parsed spec data, statistics, real-time subscriptions |
| PostgreSQL  | Optional metadata | API access logs, rate limiting (if needed)            |
| File System | Source of truth   | Original spec markdown files                          |

### Caching Architecture

**Two-Tier Caching Strategy:**

1. **L1 Cache (Memory)**:
   - In-memory Map for frequently accessed specs
   - Size limit: 50MB
   - TTL: 5 minutes
   - Use case: Hot data, recent requests

2. **L2 Cache (Redis)**:
   - Distributed cache for all parsed data
   - TTL: 1 hour
   - Event-based invalidation
   - Cache key patterns:
     - `spec:{id}` - Individual spec data
     - `stats:global` - Global statistics
     - `tree:hierarchy` - Full hierarchy tree

### Real-time Communication

**WebSocket Strategy:**

```typescript
// Event types
interface SpecEvent {
  type: 'spec_updated' | 'spec_added' | 'spec_deleted' | 'stats_updated';
  id: string;
  timestamp: Date;
  data: any;
}

// Connection management
@WebSocketGateway({ namespace: 'specs' })
export class StatusGateway {
  handleConnection(client: Socket) {
    // Subscribe client to relevant events
  }

  broadcastUpdate(event: SpecEvent) {
    // Broadcast to all connected clients
  }
}
```

**SSE Fallback:**

- Unidirectional updates for simpler clients
- Automatic reconnection handling
- Lower overhead than WebSocket

### File Watching Implementation

```typescript
// Debounced file watcher configuration
const watcher = chokidar.watch('specs/**/*.{spec,context}.md', {
  ignored: /node_modules/,
  ignoreInitial: false,
  persistent: true,
  usePolling: false, // Better performance
  awaitWriteFinish: {
    stabilityThreshold: 300,
    pollInterval: 100,
  },
});

// Event handlers with debouncing
watcher
  .on('change', debounce(handleFileChange, 300))
  .on('add', debounce(handleFileAdd, 300))
  .on('unlink', debounce(handleFileDelete, 300));
```

---

## Performance & Scalability

### Load Characteristics

| Metric               | Expected Value | Peak Value |
| -------------------- | -------------- | ---------- |
| Concurrent clients   | 10-20          | 50         |
| Requests per second  | 10             | 100        |
| File updates per day | 5-10           | 50         |
| Cache hit ratio      | 90%            | -          |

### Performance Optimizations

1. **Lazy Loading**: Load spec content only when requested
2. **Response Compression**: Gzip for API responses
3. **Connection Pooling**: Limit WebSocket connections
4. **Batch Updates**: Group multiple file changes
5. **Partial Updates**: Send only changed data to clients

### Monitoring Requirements

**Metrics to Track:**

- API response times (p50, p95, p99)
- Cache hit/miss ratios
- WebSocket connection count
- File change event frequency
- Memory usage and growth
- Error rates by endpoint

**Health Checks:**

```typescript
@Get('/health')
async healthCheck() {
  return {
    status: 'healthy',
    timestamp: new Date(),
    checks: {
      fileSystem: await this.checkFileAccess(),
      redis: await this.checkRedisConnection(),
      parsing: await this.checkParsingCapability()
    }
  };
}
```

---

## Security Architecture

### Authentication & Authorization

**Development Environment:**

- Optional authentication (configurable via environment variables)
- Open access for local development

**Production Environment:**

- JWT-based authentication
- Integration with existing JTS auth system
- Read-only access for all spec data
- No modification endpoints

### API Security Measures

1. **Rate Limiting**:
   - Redis-based rate limiting
   - 100 requests/minute per IP
   - Configurable per endpoint

2. **Input Validation**:

   ```typescript
   @Get(':id')
   async getSpec(@Param('id', SpecIdValidationPipe) id: string) {
     // Validated and sanitized input
   }
   ```

3. **Security Headers**:
   - Helmet.js integration
   - CORS configuration for dashboard domain
   - CSP headers for XSS protection

4. **Data Sanitization**:
   - No user-generated content
   - Spec IDs validated against pattern
   - Path traversal prevention

---

## Implementation Phases

### Phase 1: MVP (Week 1-2)

**Endpoints to Implement:**

```typescript
GET /api/specs              // List all specs with metadata
GET /api/specs/:id          // Get single spec details
GET /api/specs/tree         // Get hierarchy tree
GET /api/specs/stats        // Get statistics
```

**Key Deliverables:**

- Basic NestJS module structure
- File parsing using existing utilities
- In-memory caching
- Swagger documentation
- Unit tests (80% coverage)

### Phase 2: Real-time Updates (Week 3)

**Additional Features:**

- WebSocket gateway implementation
- File watcher with chokidar
- Redis caching layer
- Event broadcasting system
- Integration tests

**Endpoints:**

```typescript
WS / api / specs / watch; // WebSocket connection
GET / api / specs / events; // SSE fallback
```

### Phase 3: Optimization (Week 4+)

**Enhancements:**

- GraphQL endpoint (optional)
- Advanced filtering and search
- Performance optimizations
- Production security hardening
- E2E tests

---

## Testing Strategy

### Unit Testing

**Coverage Target: 95% for business logic**

```typescript
// Test files structure
spec - parser.service.spec.ts;
spec - watcher.service.spec.ts;
cache - manager.service.spec.ts;
statistics.service.spec.ts;
status.controller.spec.ts;
```

### Integration Testing

**Key Scenarios:**

- File system operations with temp directories
- Redis cache integration with test containers
- WebSocket connection handling
- Cache invalidation flows

### E2E Testing

**Test Cases:**

1. API endpoint schema validation
2. Real-time update propagation
3. Cache invalidation accuracy
4. File change detection timing
5. Error handling and recovery

### Performance Benchmarks

| Metric                  | Target  | Acceptable |
| ----------------------- | ------- | ---------- |
| API response time (p95) | < 100ms | < 200ms    |
| WebSocket latency       | < 50ms  | < 100ms    |
| File change detection   | < 500ms | < 1000ms   |
| Memory usage            | < 200MB | < 500MB    |

---

## Deployment Architecture

### Docker Configuration

```dockerfile
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npx nx build status-api

FROM node:20-alpine
WORKDIR /app
COPY --from=builder /app/dist/apps/status-api .
COPY --from=builder /app/specs ./specs
EXPOSE 3000 3001
CMD ["node", "main.js"]
```

### Environment Variables

```env
# Server Configuration
PORT=3000
WS_PORT=3001
NODE_ENV=production

# Redis Configuration
REDIS_URL=redis://localhost:6379
REDIS_TTL=3600

# File System
SPECS_PATH=./specs
WATCH_ENABLED=true

# Security
AUTH_ENABLED=false
RATE_LIMIT=100
CORS_ORIGIN=http://localhost:3000

# Performance
CACHE_SIZE=50
MAX_CONNECTIONS=100
```

### CI/CD Pipeline

1. **Build Stage**:
   - Nx build with production optimizations
   - Docker image creation
   - Security scanning

2. **Test Stage**:
   - Unit tests
   - Integration tests
   - Code coverage validation

3. **Deploy Stage**:
   - Docker registry push
   - Kubernetes deployment
   - Health check validation

---

## Epic Split and Dependencies

### 2025-09-04 - Epic Structure Definition

**Features Created:**

1. **F01: Spec Parser Service** (Critical - Foundation)
   - Spec file discovery and indexing
   - YAML frontmatter parser with gray-matter
   - Hierarchical ID resolver
   - In-memory spec registry

2. **F02: Spec API Gateway** (Critical)
   - RESTful endpoints (GET /api/specs, /specs/:id, /tree, /stats)
   - Response DTOs with validation
   - Raw markdown and HTML rendering support
   - Dependencies: F01

3. **F03: Real-time Updates Engine** (High)
   - WebSocket server with Socket.IO
   - File system watcher using chokidar
   - Event broadcasting system
   - Dependencies: F01

4. **F04: Caching & Performance Layer** (High)
   - Redis integration for persistent cache
   - In-memory LRU cache for hot data
   - Cache invalidation on file changes
   - Dependencies: F01, F02

5. **F05: Progress Calculation Engine** (Medium)
   - Status-based completion calculation
   - Epic/Feature/Task aggregation
   - Dependency chain analysis
   - Dependencies: F01

6. **F06: Security & Resilience Module** (Medium)
   - Rate limiting with @nestjs/throttler
   - Request validation and sanitization
   - Circuit breaker for file operations
   - Dependencies: F02, F03

### Dependency Analysis

**Critical Path**: F01 → F02 → F04

**Parallel Development Opportunities**:

- F03 and F04 can be developed simultaneously after F01
- F05 can start once F01 data structures are defined
- F06 should be integrated incrementally throughout

**Integration Points**:

- F01 provides the data model for all other features
- F04 sits between data providers (F01, F05) and consumers (F02, F03)
- F06 wraps all external-facing features (F02, F03)

## Implementation Log

### 2025-09-04 - Initial Architecture Design & Epic Split

**Completed:**

- Used software architect agent for comprehensive analysis
- Split epic into 6 logical features with clear dependencies
- Defined three-phase implementation approach
- Created detailed risk assessment and mitigation strategies
- Technology stack selection
- Testing and deployment strategies

**Architecture Decisions:**

- Use hybrid microservice architecture for flexibility
- Implement two-tier caching for performance
- WebSocket primary with SSE fallback for real-time updates
- Phased implementation approach for incremental delivery

**Next Steps:**

1. Create feature spec files for F01-F06
2. Begin Phase 1 MVP implementation with F01 and basic F02
3. Set up NestJS service structure
4. Integrate existing spec parsing utilities

---

## References

- [NestJS WebSocket Documentation](https://docs.nestjs.com/websockets/gateways)
- [Chokidar File Watching](https://github.com/paulmillr/chokidar)
- [Gray Matter YAML Parser](https://github.com/jonschlinkert/gray-matter)
- [Redis Caching Strategies](https://redis.io/docs/manual/patterns/indexes/)
